# 算法原理速查手册

> **目的**: 从原理出发理解每个算法，建立系统性知识框架
> **使用方法**: 每次操作前先阅读对应章节

---

## 目录

1. [点云基础](#1-点云基础)
2. [聚类算法](#2-聚类算法)
3. [图论方法](#3-图论方法)
4. [几何拟合](#4-几何拟合)
5. [深度学习](#5-深度学习预览)

---

## 1. 点云基础

### 1.1 什么是点云？

```
点云 = {(x₁, y₁, z₁), (x₂, y₂, z₂), ..., (xₙ, yₙ, zₙ)}

每个点可以附带属性:
- 强度 (Intensity): 激光反射强度
- RGB: 颜色信息
- 分类 (Classification): 地面/植被/建筑
- 法向量 (Normal): 表面朝向
```

### 1.2 LiDAR 原理

```
激光雷达 (Light Detection and Ranging) 工作流程:

1. 发射激光脉冲
   ┌──────┐
   │发射器│ ─→ )))))) 激光脉冲
   └──────┘

2. 激光碰到物体反射
   )))))) → 🌲 → ((((((

3. 接收反射信号，计算距离
   距离 = (光速 × 时间差) / 2

4. 结合传感器姿态，计算 3D 坐标
   (x, y, z) = f(距离, 角度, 传感器位置)
```

### 1.3 UAV-LiDAR vs TLS

| 特性 | UAV-LiDAR | TLS (地面激光扫描) |
|------|-----------|-------------------|
| 视角 | 俯视 | 侧视 |
| 覆盖 | 大面积 | 小面积高精度 |
| 树冠 | 完整 | 遮挡多 |
| 树干 | 遮挡多 | 完整 |
| 点密度 | 中等 | 很高 |

---

## 2. 聚类算法

### 2.1 DBSCAN

**全称**: Density-Based Spatial Clustering of Applications with Noise

**核心思想**: 密度可达性

```
定义:
┌─────────────────────────────────────────────────────────┐
│                                                          │
│  eps (ε): 邻域半径                                       │
│  min_samples: 核心点需要的最少邻居数                       │
│                                                          │
│  直接密度可达 (Directly Density-Reachable):              │
│  如果 q 在 p 的 eps 邻域内，且 p 是核心点，               │
│  则 q 从 p 直接密度可达                                   │
│                                                          │
│  密度可达 (Density-Reachable):                           │
│  如果存在一条"直接密度可达"的链，                          │
│  p₁ → p₂ → ... → pₙ，则 pₙ 从 p₁ 密度可达                │
│                                                          │
│  密度相连 (Density-Connected):                           │
│  如果 p 和 q 都从某个点 o 密度可达，                       │
│  则 p 和 q 密度相连                                      │
│                                                          │
└─────────────────────────────────────────────────────────┘

算法流程:
1. foreach 未访问的点 p:
2.   if p 的邻域内点数 ≥ min_samples:
3.     p 是核心点，创建新簇
4.     扩展簇（添加所有密度可达的点）
5.   else:
6.     标记 p 为噪声（可能后续被边界点吸收）
```

**时间复杂度**: O(n²)，使用 KD-Tree 可优化到 O(n log n)

**为什么适合树木分割**:
- 树木是"密度岛"
- 树与树之间是"低密度区"
- 不需要预先知道树木数量

### 2.2 HDBSCAN

**全称**: Hierarchical DBSCAN

**改进点**: 自动选择 eps

```
DBSCAN 问题:
- 需要手动选择 eps
- 不同密度区域表现不一

HDBSCAN 解决方案:
- 构建层次聚类树
- 从树中提取最稳定的簇
- 自动适应不同密度

                 ┌─────────────┐
                 │  所有点     │
                 └──────┬──────┘
                        │
         ┌──────────────┼──────────────┐
         │              │              │
    ┌────┴────┐    ┌────┴────┐    ┌────┴────┐
    │  簇 1   │    │  簇 2   │    │  噪声   │
    └────┬────┘    └────┬────┘    └─────────┘
         │              │
    ┌────┴────┐    ┌────┴────┐
    │ 子簇1.1 │    │ 子簇2.1 │
    └─────────┘    └─────────┘
```

### 2.3 K-Means（对比参考）

```
K-Means vs DBSCAN:

┌─────────────────────────────────────────────────────────┐
│  K-Means:                    DBSCAN:                    │
│                                                          │
│  ● 需要预设 K 值             ● 不需要预设簇数量            │
│  ● 只能发现球形簇            ● 可以发现任意形状            │
│  ● 对噪声敏感               ● 自动识别噪声                 │
│  ● 时间复杂度 O(nKt)        ● 时间复杂度 O(n²) 或更优      │
│                                                          │
└─────────────────────────────────────────────────────────┘

为什么不用 K-Means 做树木分割？
- 不知道有多少棵树
- 树木形状不规则
- 存在大量噪声点
```

---

## 3. 图论方法

### 3.1 Graph-Cut (图割)

**核心思想**: 将分割问题转化为图的最小割问题

```
1. 构建图
   ┌─────────────────────────────────────────────────────┐
   │                                                      │
   │  节点 V = {v₁, v₂, ..., vₙ}  (每个点是一个节点)       │
   │                                                      │
   │  边 E = {(vᵢ, vⱼ)}  (连接相邻点)                     │
   │                                                      │
   │  边权重 w(vᵢ, vⱼ) = f(距离, 特征相似度)               │
   │                                                      │
   └─────────────────────────────────────────────────────┘

2. 定义能量函数
   E(L) = Σ Dᵢ(Lᵢ) + λ Σ Vᵢⱼ(Lᵢ, Lⱼ)
          i          i,j
   
   Dᵢ(Lᵢ): 数据项 - 点 i 属于标签 Lᵢ 的代价
   Vᵢⱼ: 平滑项 - 相邻点有不同标签的代价
   λ: 平衡参数

3. 最小化能量
   L* = argmin E(L)
   
   使用 Max-Flow / Min-Cut 算法求解
```

**Treeiso 特殊之处**:
- 设计了针对树木的能量函数
- 考虑树木的垂直结构
- 处理树冠交叠

### 3.2 Connected Components (连通分量)

```
简化版图方法:

1. 构建图（相邻点连边）
2. 使用 BFS/DFS 或 Union-Find 找连通区域
3. 每个连通区域是一棵树

优点: 简单快速
缺点: 树冠交叠时会合并
```

---

## 4. 几何拟合

### 4.1 RANSAC

**全称**: Random Sample Consensus

```
核心思想: 随机采样 + 假设验证

算法流程:
┌─────────────────────────────────────────────────────────┐
│                                                          │
│  for i = 1 to max_iterations:                           │
│    1. 随机选择最小点集（圆柱需要 3-5 个点）                │
│    2. 拟合模型（圆柱参数: 轴方向, 半径, 中心）             │
│    3. 计算所有点到模型的距离                              │
│    4. 统计内点数量（距离 < threshold 的点）               │
│    5. 如果内点数 > 最佳记录，更新最佳模型                  │
│                                                          │
│  使用所有内点重新拟合，得到最终模型                        │
│                                                          │
└─────────────────────────────────────────────────────────┘

为什么用于树干检测？
- 树干近似圆柱体
- 点云有噪声和遮挡
- RANSAC 对离群点鲁棒
```

### 4.2 最小二乘圆拟合

```
问题: 给定 2D 点集，拟合最佳圆

圆方程: (x - a)² + (y - b)² = r²

展开: x² + y² - 2ax - 2by + (a² + b² - r²) = 0

令 c = a² + b² - r²

线性化: 2ax + 2by + c = x² + y²

矩阵形式:
┌         ┐ ┌   ┐   ┌           ┐
│ 2x₁ 2y₁ 1│ │ a │   │ x₁² + y₁² │
│ 2x₂ 2y₂ 1│ │ b │ = │ x₂² + y₂² │
│ ...      │ │ c │   │ ...       │
└         ┘ └   ┘   └           ┘

最小二乘解: (AᵀA)⁻¹Aᵀb

r = √(a² + b² - c)
```

---

## 5. 深度学习（预览）

### 5.1 PointNet

**问题**: 如何直接处理无序点云？

```
传统方法: 点云 → 体素化 → 3D CNN
问题: 信息损失、计算量大

PointNet 创新:
┌─────────────────────────────────────────────────────────┐
│                                                          │
│  输入: (N, 3) 点云  [无序]                               │
│         ↓                                                │
│  逐点 MLP (共享权重)                                      │
│         ↓                                                │
│  每个点得到特征 (N, 1024)                                 │
│         ↓                                                │
│  Max Pooling (对称函数，解决无序问题)                      │
│         ↓                                                │
│  全局特征 (1, 1024)                                      │
│         ↓                                                │
│  分类/分割头                                              │
│                                                          │
└─────────────────────────────────────────────────────────┘

关键: Max Pooling 是对称函数
f({x₁, x₂, x₃}) = f({x₃, x₁, x₂})
```

### 5.2 PointNet++（下一步学习目标）

```
PointNet 问题: 缺乏局部结构信息

PointNet++ 解决方案: 层次化采样 + 分组

┌─────────────────────────────────────────────────────────┐
│                                                          │
│  Set Abstraction Layer:                                 │
│                                                          │
│  1. Sampling: 使用 FPS (Farthest Point Sampling)        │
│     选择 N' 个中心点                                     │
│                                                          │
│  2. Grouping: 对每个中心点，找 K 个邻居                   │
│     形成局部区域                                         │
│                                                          │
│  3. PointNet: 对每个局部区域应用 PointNet                │
│     提取局部特征                                         │
│                                                          │
│  4. 重复，形成层次结构                                    │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

---

## 📚 延伸阅读

| 主题 | 推荐资源 |
|------|---------|
| DBSCAN | sklearn 文档 + 维基百科 |
| RANSAC | OpenCV 教程 |
| PointNet | 原论文 + YouTube 讲解 |
| Graph-Cut | 《计算机视觉》Szeliski |

---

*学习建议: 每天花 15-30 分钟阅读原理，动手前先理解"为什么"*
