# ITI 学习任务清单

> **学习原则**: 原理先行，目标导向，系统思维  
> **时间**: 2026-01-31 至 2026-02-05

---

## 📖 阅读指南

每个任务包含：
- ☐ **任务描述**: 具体要做什么
- 📐 **算法原理**: 为什么这样做
- 🎯 **目标关联**: 与久保田/论文的联系
- 📸 **截图要求**: 需要保存的证据

---

## Day 1: 基础实践（1月31日）

### Task 1.1: CloudCompare 连通分量分割

```
☐ 完成
```

**操作步骤**:
1. 打开 `01_Processed/San Juan Fault/Off-Ground_Good-5m.ply`
2. 执行 `Edit > Label Connected Components`
3. 设置 Octree Level = 10, Min points = 100
4. 观察分割结果

**📐 算法原理: Connected Components**

```
连通分量算法工作流程:

1. 空间索引构建 (Octree)
   ┌────────────────────┐
   │ 将 3D 空间递归划分  │
   │ 为八叉树结构        │
   │ Level 越高，格子越小 │
   └────────────────────┘
           ↓
2. 邻接关系判断
   ┌────────────────────┐
   │ 如果两个点在相邻    │
   │ 的格子中，判定为    │
   │ "连通"             │
   └────────────────────┘
           ↓
3. 连通区域合并
   ┌────────────────────┐
   │ 使用 Union-Find    │
   │ 将连通点合并为一个  │
   │ 组件（Component）   │
   └────────────────────┘

关键参数影响:
- Octree Level ↑ → 分割更细（可能过分割）
- Octree Level ↓ → 分割更粗（可能欠分割）
- Min points ↑ → 过滤更多小噪声
```

**🎯 目标关联**:
- **农机应用**: 障碍物检测需要快速分割点云为独立对象
- **论文价值**: 作为基准方法对比深度学习效果

**📸 截图要求**:

| 截图内容 | 文件名 | 保存位置 |
|---------|--------|---------|
| CC 分割结果（彩色） | `day1_cc_result_octree10.png` | `02_Screenshots/` |
| CC 分割结果（Octree8） | `day1_cc_result_octree8.png` | `02_Screenshots/` |
| CC 参数设置界面 | `day1_cc_params.png` | `02_Screenshots/` |

---

### Task 1.2: Python DBSCAN 运行

```
☐ 完成
```

**操作命令**:
```bash
cd /Users/zyc/Downloads/Niigata_Research_Prep
python 03_Scripts/tree_isolation_dbscan.py
```

**📐 算法原理: DBSCAN**

```
DBSCAN (Density-Based Spatial Clustering of Applications with Noise)

核心概念:
┌─────────────────────────────────────────────────────────┐
│                                                          │
│  ● 核心点 (Core Point):                                  │
│    在 eps 半径内有 ≥ min_samples 个邻居                   │
│                                                          │
│  ○ 边界点 (Border Point):                                │
│    在核心点的 eps 邻域内，但自己不是核心点                  │
│                                                          │
│  × 噪声点 (Noise):                                       │
│    既不是核心点也不是边界点                                │
│                                                          │
└─────────────────────────────────────────────────────────┘

工作流程:
1. 对每个点，计算 eps 邻域内的点数
2. 标记核心点
3. 从任一核心点开始，递归扩展簇
4. 重复直到所有核心点被访问
5. 剩余点标记为噪声

为什么用 2D 投影？
┌─────────────────────────────────────────────────────────┐
│ 树干是垂直生长的                                          │
│                                                          │
│ 3D 聚类问题:          2D 投影解决方案:                     │
│      ║                      •                            │
│      ║  ← 遮挡断裂           •  ← 投影后连续               │
│      ║                      •                            │
│      ╳  ← 被分成两棵树                                    │
│      ║                                                   │
│      ║                                                   │
└─────────────────────────────────────────────────────────┘

参数调优指南:
┌────────────┬────────────┬────────────────────────────────┐
│ 参数        │ 作用        │ 调整建议                        │
├────────────┼────────────┼────────────────────────────────┤
│ eps ↑      │ 簇变大      │ 树被合并 → 减小 eps             │
│ eps ↓      │ 簇变小      │ 树被分割 → 增大 eps             │
│ min_samples↑│ 更多噪声    │ 小树被忽略 → 减小               │
│ min_samples↓│ 更多小簇    │ 噪声变多 → 增大                 │
└────────────┴────────────┴────────────────────────────────┘
```

**🎯 目标关联**:
- **农机应用**: DBSCAN 是实时障碍物分割的常用算法
- **论文价值**: 传统方法基准，可与 PointNet++ 对比
- **技能迁移**: scikit-learn 是工业界标准库

**📸 截图要求**:

| 截图内容 | 文件名 | 保存位置 |
|---------|--------|---------|
| DBSCAN 3D 可视化 | `day1_dbscan_3d_viz.png` | `02_Screenshots/` |
| 终端运行输出 | `day1_dbscan_terminal.png` | `02_Screenshots/` |

---

### Task 1.3: 记录对比观察

```
☐ 完成
```

**创建文件**: `04_Results/reports/day1_observations.md`

**记录内容**:
- CC 分割了多少棵树？
- DBSCAN 分割了多少棵树？
- 哪种方法效果更好？为什么？

---

## Day 2: 参数优化与 Treeiso（2月1日）

### Task 2.1: DBSCAN 参数网格搜索

```
☐ 完成
```

**操作命令**:
```bash
python 03_Scripts/run_dbscan_experiments.py
```

**📐 算法原理: 超参数搜索**

```
网格搜索 (Grid Search) 原理:
┌─────────────────────────────────────────────────────────┐
│                                                          │
│  eps       0.3   0.5   0.8   1.0   1.5                  │
│            ─────────────────────────────                 │
│  min=30   │ ● │ ● │ ● │ ● │ ● │                         │
│  min=50   │ ● │ ★ │ ● │ ● │ ● │  ← 找到最优              │
│  min=100  │ ● │ ● │ ● │ ● │ ● │                         │
│  min=150  │ ● │ ● │ ● │ ● │ ● │                         │
│            ─────────────────────────────                 │
│                                                          │
│  评估指标:                                                │
│  - 检测到的树数量 (越接近真实越好)                          │
│  - 噪声比例 (越低越好)                                    │
│  - 平均每棵树点数 (合理范围为佳)                           │
│                                                          │
└─────────────────────────────────────────────────────────┘

为什么需要参数调优？
- 不同数据集的点密度不同
- 不同树种的间距不同
- 没有"万能"参数
```

**🎯 目标关联**:
- **通用技能**: 超参数调优是任何 ML 项目的核心能力
- **论文必备**: 需要报告最优参数和消融实验

**📸 截图要求**:

| 截图内容 | 文件名 | 保存位置 |
|---------|--------|---------|
| 实验结果表格 | `day2_experiments_table.png` | `02_Screenshots/` |
| 最优参数效果 | `day2_best_params_result.png` | `02_Screenshots/` |

---

### Task 2.2: Treeiso 安装与测试

```
☐ 完成
```

**📐 算法原理: Graph-Cut (图割)**

```
Treeiso 使用的 Graph-Cut 分割原理:

1. 构建图结构
   ┌─────────────────────────────────────────────────────┐
   │ 点云 → 图 (Graph)                                    │
   │                                                      │
   │ 节点 (Node) = 每个点                                  │
   │ 边 (Edge) = 点之间的连接关系                          │
   │ 边权重 = 距离/相似度                                  │
   └─────────────────────────────────────────────────────┘

2. 最小割问题
   ┌─────────────────────────────────────────────────────┐
   │                                                      │
   │    🌲 Tree A          🌲 Tree B                      │
   │      ●──●              ●──●                          │
   │      │  │              │  │                          │
   │      ●──●──────────────●──●                          │
   │           ↑                                          │
   │        割边（最小化跨树连接）                          │
   │                                                      │
   └─────────────────────────────────────────────────────┘

3. 能量最小化
   E = E_data + λ × E_smooth
   
   - E_data: 数据项（点属于哪棵树的可能性）
   - E_smooth: 平滑项（相邻点应属于同一棵树）
   - λ: 平衡参数

为什么 Treeiso 比 DBSCAN 更适合密集林？
- DBSCAN 只看距离
- Treeiso 考虑全局最优分割
- 能处理树冠交叠情况
```

**🎯 目标关联**:
- **学术前沿**: Graph-Cut 是计算机视觉经典方法
- **深度学习铺垫**: 理解后更容易学习 GNN（图神经网络）

**📸 截图要求**:

| 截图内容 | 文件名 | 保存位置 |
|---------|--------|---------|
| Treeiso 安装成功 | `day2_treeiso_install.png` | `02_Screenshots/` |
| Treeiso 运行结果 | `day2_treeiso_result.png` | `02_Screenshots/` |

---

## Day 3: 完整流程与 DBH 测量（2月2日）

### Task 3.1: 运行完整 Pipeline

```
☐ 完成
```

**操作命令**:
```bash
python 03_Scripts/full_iti_pipeline.py
```

**📐 算法原理: DBH 测量**

```
DBH (Diameter at Breast Height) 测量原理:

1. 定义高度切片
   ┌─────────────────────────────────────────────────────┐
   │                                                      │
   │      ╱╲                                              │
   │     ╱  ╲                                             │
   │    ╱    ╲                                            │
   │   ║      ║  ← 1.3m 高度                              │
   │   ║======║  ← 切片厚度 10cm                          │
   │   ║      ║                                           │
   │   ║      ║                                           │
   │ ══╬══════╬══  ← 地面                                 │
   │                                                      │
   └─────────────────────────────────────────────────────┘

2. 圆拟合方法

   方法A: 2D 最小二乘圆拟合
   - 将切片点投影到 XY 平面
   - 拟合圆: (x-a)² + (y-b)² = r²
   - 优点: 快速，适合薄切片
   
   方法B: 3D RANSAC 圆柱拟合
   - 在 3D 空间拟合圆柱体
   - 优点: 更鲁棒，能处理倾斜树干
   - 你已实现: tree_utils.py

3. 精度验证
   - 手动测量 vs 自动测量
   - 计算 RMSE、MAE
```

**🎯 目标关联**:
- **森林调查核心**: DBH 是最重要的树木参数
- **论文标准数据**: 几乎所有 ITI 论文都报告 DBH 精度

**📸 截图要求**:

| 截图内容 | 文件名 | 保存位置 |
|---------|--------|---------|
| Pipeline 运行完成 | `day3_pipeline_complete.png` | `02_Screenshots/` |
| 3D 可视化总览 | `day3_isolated_trees_overview.png` | `02_Screenshots/` |
| 单棵树点云示例 | `day3_single_tree_example.png` | `02_Screenshots/` |

---

### Task 3.2: 手动验证 DBH

```
☐ 完成
```

**操作步骤**:
1. 在 CloudCompare 打开 3 棵分离出的树
2. 使用 Cross Section 切片
3. 使用 Tools > Fit > Circle 测量
4. 与 CSV 结果对比

**📸 截图要求**:

| 截图内容 | 文件名 | 保存位置 |
|---------|--------|---------|
| CC 手动测量过程 | `day3_manual_dbh_measure.png` | `02_Screenshots/` |

---

## Day 4: 方法对比分析（2月3日）

### Task 4.1: 运行对比脚本

```
☐ 完成
```

**操作命令**:
```bash
python 03_Scripts/compare_iti_ransac.py
```

**📐 算法原理: 方法评估指标**

```
常用评估指标:

1. RMSE (均方根误差)
   RMSE = √(Σ(预测值 - 真实值)² / n)
   - 对大误差敏感
   - 单位与原始数据相同

2. MAE (平均绝对误差)
   MAE = Σ|预测值 - 真实值| / n
   - 更直观的"平均错了多少"

3. R² (决定系数)
   R² = 1 - SS_res / SS_tot
   - 范围 [0, 1]，1 表示完美拟合

4. Bland-Altman 图
   ┌─────────────────────────────────────────────────────┐
   │  差值                                               │
   │    ↑                                                │
   │ +1.96SD ────────────────────────────               │
   │         ○     ○                                     │
   │ Mean   ─○──○────○──○──○────────────                │
   │              ○       ○                              │
   │ -1.96SD ────────────────────────────               │
   │    └────────────────────────────→ 平均值           │
   │                                                     │
   │  用于评估两种方法的一致性                             │
   └─────────────────────────────────────────────────────┘
```

**🎯 目标关联**:
- **论文必备**: 任何方法论文都需要定量对比
- **工业标准**: 久保田评估传感器精度也用类似指标

**📸 截图要求**:

| 截图内容 | 文件名 | 保存位置 |
|---------|--------|---------|
| 对比散点图 | `day4_comparison_scatter.png` | `02_Screenshots/` |
| Bland-Altman 图 | `day4_bland_altman.png` | `02_Screenshots/` |

---

### Task 4.2: 撰写分析笔记

```
☐ 完成
```

**创建文件**: `04_Results/reports/comparison_notes.md`

**必须回答的问题**:
1. 哪种方法检测到更多树？
2. DBH 测量精度哪个更高？
3. 哪种方法更适合密集林？
4. 如何结合两种方法的优势？

---

## Day 5: 整理与 Demo 准备（2月4日）

### Task 5.1: 整理学习成果

```
☐ 完成
```

**更新文件**: `04_Results/reports/iti_learning_summary.md`

- 添加实验数据
- 插入关键截图
- 总结学到的技术

### Task 5.2: 准备面试 Demo

```
☐ 完成
```

**Demo 流程设计** (约 5 分钟):

```
1. 简介 (30秒)
   "这是我的单木分离学习项目"

2. 展示 CloudCompare 结果 (1分钟)
   - 显示分割后的彩色点云

3. 运行 Python Pipeline (2分钟)
   - 展示代码运行
   - 解释关键输出

4. 展示对比分析 (1分钟)
   - 展示对比图表
   - 解释技术选择

5. 总结 (30秒)
   - 学到了什么
   - 下一步计划
```

**📸 截图要求**:

| 截图内容 | 文件名 | 保存位置 |
|---------|--------|---------|
| 最终成果总览 | `day5_final_overview.png` | `02_Screenshots/` |

---

## Day 6: 缓冲日（2月5日）

### Task 6.1: 查漏补缺

```
☐ 完成
```

- 检查所有截图是否齐全
- 测试 Demo 流程
- Zoom 屏幕共享测试

### Task 6.2: 日语准备开始

```
☐ 完成
```

- 准备技术术语日语表达
- 练习自我介绍

---

## 📊 截图命名规范总结

| 格式 | 示例 |
|------|------|
| `dayX_主题_细节.png` | `day1_cc_result_octree10.png` |

**保存位置**: 全部放入 `02_Screenshots/`

---

## ✅ 完成度追踪

| Day | 任务数 | 完成数 | 状态 |
|-----|-------|-------|------|
| 1 | 3 | 0 | ⬜ |
| 2 | 2 | 0 | ⬜ |
| 3 | 2 | 0 | ⬜ |
| 4 | 2 | 0 | ⬜ |
| 5 | 2 | 0 | ⬜ |
| 6 | 2 | 0 | ⬜ |

---

*每完成一项任务，将 `☐` 改为 `☑`*
